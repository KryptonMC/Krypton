/*
 * This file is part of the Krypton project, licensed under the GNU General Public License v3.0
 *
 * Copyright (C) 2021 KryptonMC and the contributors of the Krypton project
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package org.kryptonmc.codegen.blocks

import com.google.gson.JsonObject
import com.google.gson.stream.JsonReader
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import me.bardy.gsonkt.fromJson
import org.apache.logging.log4j.LogManager
import org.kryptonmc.codegen.Generator
import org.kryptonmc.codegen.camelCase
import java.io.File
import java.io.InputStream
import java.io.InputStreamReader
import javax.lang.model.element.Modifier

class BlockGenerator(
    private val blocksFile: InputStream?,
    private val blockPropertyFile: InputStream?,
    private val kotlinOutput: File,
    private val javaOutput: File
) : Generator() {

    override fun generate() {
        if (blocksFile == null) {
            LOGGER.error("Failed to find blocks.json!")
            LOGGER.error("Stopped code generation for blocks!")
            return
        }
        if (blockPropertyFile == null) {
            LOGGER.error("Failed to find block_properties.json!")
            LOGGER.error("Stopped code generation for block properties!")
            return
        }

        if ((!kotlinOutput.exists() && !kotlinOutput.mkdirs()) || (!javaOutput.exists() && !javaOutput.mkdirs())) {
            LOGGER.error("Output folder(s) for generated code does not exist and could not be created!")
            return
        }

        val blocks = GSON.fromJson<JsonObject>(JsonReader(InputStreamReader(blocksFile)))
        val blockClassName = ClassName("org.kryptonmc.krypton.world.block", "BlockData")
        val blockAlternativeClassName = com.squareup.javapoet.ClassName.get("org.kryptonmc.krypton.world.block", "BlockAlternative")
        val blocksObjectName = ClassName("org.kryptonmc.krypton.world.block", "Blocks")
        val kotlinFiles = mutableListOf<FileSpec>()
        val javaFiles = mutableListOf<JavaFile>()

        val blocksFile = FileSpec.builder("org.kryptonmc.krypton.world.block", blocksObjectName.simpleName).indent("    ")
        val blocksObject = TypeSpec.objectBuilder(blocksObjectName)
            .addKdoc("""
                WARNING: This class is automatically generated by class ${javaClass.simpleName}!
                DO NOT MODIFY THIS CLASS DIRECTLY!
            """.trimIndent())
        val initBlock = CodeBlock.builder()
        blocks.entrySet().asSequence().map { it.key to it.value.asJsonObject }.forEach blocks@{ (name, block) ->
            val blockName = block["mojangName"].asString
            val states = block["states"].asJsonArray
            blocksObject.addProperty(PropertySpec.builder(blockName, blockClassName)
                .addAnnotation(JvmField::class)
                .initializer("register(\"$name\", " +
                        "${block["defaultStateId"].asShort}, " +
                        "${states[0].asJsonObject["hardness"].asDouble}, " +
                        "${block["explosionResistance"].asDouble}, " +
                        "${states[0].asJsonObject["air"].asBoolean}, " +
                        "${states[0].asJsonObject["solid"].asBoolean}, " +
                        "${block["blockEntity"].asBoolean}, " +
                        "${states.size() == 1})"
                )
                .build())
            if (states.size() > 1) {
                val stateClassName = com.squareup.javapoet.ClassName.get("org.kryptonmc.krypton.world.block.state", blockName.lowercase().camelCase())

                val stateClass = com.squareup.javapoet.TypeSpec.classBuilder(stateClassName)
                    .addJavadoc("""
                        WARNING: This class is automatically generated by class ${javaClass.simpleName}!
                        DO NOT MODIFY THIS CLASS DIRECTLY!
                    """.trimIndent())
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)

                val initMethod = MethodSpec.methodBuilder("init").addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                states.asSequence().map { it.asJsonObject }.forEach { state ->
                    val properties = state["properties"].asJsonObject
                    if (properties.size() != 0) {
                        val propertiesString = StringBuilder(properties.entrySet().joinToString { "\"${it.key}=${it.value.toString().replace("\"", "\\\"")}\"" })
                        propertiesString.deleteRange(propertiesString.lastIndex - 2, propertiesString.lastIndex)
                        initMethod.addStatement(com.squareup.javapoet.CodeBlock.of(
                            "\$T.\$L.addAlternative(new \$T((short) \$L, \$T.of($propertiesString)))",
                            com.squareup.javapoet.ClassName.get("org.kryptonmc.krypton.world.block", "Blocks"),
                            blockName,
                            blockAlternativeClassName,
                            state["stateId"].asShort,
                            java.util.List::class.java
                        ))
                    } else {
                        initMethod.addStatement(com.squareup.javapoet.CodeBlock.of(
                            "\$T.\$L.addAlternative(new \$T((short) \$L))",
                            com.squareup.javapoet.ClassName.get("org.kryptonmc.krypton.world.block", "Blocks"),
                            blockName,
                            blockAlternativeClassName,
                            state["stateId"].asShort
                        ))
                    }
                }

                stateClass.addMethod(initMethod.build())
                blocksFile.addImport(stateClassName.packageName(), stateClassName.simpleName())
                initBlock.addStatement("${stateClassName.simpleName()}.init()")
                javaFiles += JavaFile.builder("org.kryptonmc.krypton.world.block.state", stateClass.build())
                    .indent("    ")
                    .skipJavaLangImports(true)
                    .build()
            }
        }
        blocksObject.addInitializerBlock(initBlock.build())
        blocksObject.addFunction(FunSpec.builder("register")
            .addAnnotation(JvmStatic::class)
            .addModifiers(KModifier.PRIVATE)
            .returns(blockClassName)
            .addParameter("key", String::class)
            .addParameter("defaultState", Short::class)
            .addParameter("hardness", Double::class)
            .addParameter("resistance", Double::class)
            .addParameter("isAir", Boolean::class)
            .addParameter("isSolid", Boolean::class)
            .addParameter("isBlockEntity", Boolean::class)
            .addParameter("hasSingleState", Boolean::class)
            .addStatement("return Registries.register(InternalRegistries.BLOCK, key, BlockData(key, defaultState, hardness, resistance, isAir, isSolid, isBlockEntity, hasSingleState))")
            .build())

        kotlinFiles += blocksFile
            .addImport("org.kryptonmc.api.registry", "Registries")
            .addImport("org.kryptonmc.krypton.registry", "InternalRegistries")
            .addType(blocksObject.build())
            .build()
        writeFiles(kotlinFiles, kotlinOutput)
        writeFiles(javaFiles, javaOutput)
    }

    companion object {

        private val LOGGER = LogManager.getLogger(BlockGenerator::class.java)
    }
}
