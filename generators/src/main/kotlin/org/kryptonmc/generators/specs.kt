/*
 * This file is part of the Krypton project, licensed under the Apache License v2.0
 *
 * Copyright (C) 2021-2023 KryptonMC and the contributors of the Krypton project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.kryptonmc.generators

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.jvm.jvmField
import com.squareup.kotlinpoet.jvm.jvmStatic

const val PACKAGE: String = "org.kryptonmc.api"
private const val REGISTRY_PACKAGE = "$PACKAGE.registry"
private val catalogueClassName = ClassName("org.kryptonmc.internal.annotations", "Catalogue")
private val registryReference = ClassName(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Builder.catalogue(parameterClassName: String): TypeSpec.Builder =
    addAnnotation(AnnotationSpec.builder(catalogueClassName).addMember("$parameterClassName::class").build())

fun TypeSpec.Builder.field(name: String, returnType: TypeName, initializer: String): TypeSpec.Builder =
    addProperty(PropertySpec.builder(name, returnType).jvmField().initializer(initializer).build())

fun TypeSpec.Builder.autoGenerated(): TypeSpec.Builder = addKdoc("This file is auto-generated. Do not edit this manually!")

fun FileSpec.Companion.catalogueType(name: ClassName): FileSpec.Builder = builder(name.packageName, name.canonicalName)
    .indent("    ")
    .addImport("net.kyori.adventure.key", "Key")
    .addImport(REGISTRY_PACKAGE, "Registries")
    .addImport(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Companion.catalogueType(name: ClassName, returnType: ClassName): TypeSpec.Builder =
    objectBuilder(name).autoGenerated().catalogue(returnType.simpleName)

fun TypeSpec.Builder.registryOfMethod(returnType: TypeName, registryName: String): TypeSpec.Builder {
    return privateStaticFunction("of", registryReference.parameterizedBy(returnType)) {
        addParameter("name", STRING)
        addCode("return·RegistryReference.of(Registries.$registryName,·Key.key(name))")
    }
}

fun <T> TypeSpec.Builder.catalogueField(field: CollectedField<T>, returnType: TypeName, keyGetter: KeyGetter<T>): TypeSpec.Builder =
    field(field.name, registryReference.parameterizedBy(returnType), "of(\"${keyGetter.key(field).path}\")")

inline fun TypeSpec.Builder.privateStaticFunction(
    name: String,
    returnType: TypeName,
    builder: FunSpec.Builder.() -> Unit = {}
): TypeSpec.Builder = addFunction(FunSpec.builder(name).addModifiers(KModifier.PRIVATE).returns(returnType).jvmStatic().apply(builder).build())
