/*
 * This file is part of the Krypton project, licensed under the GNU General Public License v3.0
 *
 * Copyright (C) 2021-2022 KryptonMC and the contributors of the Krypton project
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
package org.kryptonmc.generators

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.STRING
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.jvm.jvmField
import com.squareup.kotlinpoet.jvm.jvmStatic

const val PACKAGE: String = "org.kryptonmc.api"
private const val REGISTRY_PACKAGE = "$PACKAGE.registry"
private val catalogueClassName = ClassName("org.kryptonmc.internal.annotations", "Catalogue")
private val registryReference = ClassName(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Builder.catalogue(parameterClassName: String): TypeSpec.Builder =
    addAnnotation(AnnotationSpec.builder(catalogueClassName).addMember("$parameterClassName::class").build())

fun TypeSpec.Builder.field(name: String, returnType: TypeName, initializer: String): TypeSpec.Builder =
    addProperty(PropertySpec.builder(name, returnType).jvmField().initializer(initializer).build())

fun TypeSpec.Builder.autoGenerated(): TypeSpec.Builder = addKdoc("This file is auto-generated. Do not edit this manually!")

fun FileSpec.Companion.catalogueType(name: ClassName): FileSpec.Builder = builder(name.packageName, name.canonicalName)
    .indent("    ")
    .addImport("net.kyori.adventure.key", "Key")
    .addImport(REGISTRY_PACKAGE, "Registries")
    .addImport(REGISTRY_PACKAGE, "RegistryReference")

fun TypeSpec.Companion.catalogueType(name: ClassName, returnType: ClassName): TypeSpec.Builder =
    objectBuilder(name).autoGenerated().catalogue(returnType.simpleName)

fun TypeSpec.Builder.registryOfMethod(returnType: TypeName, registryName: String): TypeSpec.Builder {
    return privateStaticFunction("of", registryReference.parameterizedBy(returnType)) {
        addParameter("name", STRING)
        addCode("return·RegistryReference.of(Registries.$registryName,·Key.key(name))")
    }
}

fun <T> TypeSpec.Builder.catalogueField(field: CollectedField<T>, returnType: TypeName, keyGetter: KeyGetter<T>): TypeSpec.Builder =
    field(field.name, registryReference.parameterizedBy(returnType), "of(\"${keyGetter.key(field).path}\")")

inline fun TypeSpec.Builder.privateStaticFunction(
    name: String,
    returnType: TypeName,
    builder: FunSpec.Builder.() -> Unit = {}
): TypeSpec.Builder = addFunction(FunSpec.builder(name).addModifiers(KModifier.PRIVATE).returns(returnType).jvmStatic().apply(builder).build())
